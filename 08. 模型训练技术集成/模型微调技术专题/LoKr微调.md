# LoKr (Low-rank Kronecker Product Adaptation)** å¾®è°ƒæ–¹æ³•

## 1. å®šä¹‰

**LoKr** æ˜¯ä¸€ç§å‚æ•°é«˜æ•ˆå¾®è°ƒï¼ˆPEFT, Parameter-Efficient Fine-Tuningï¼‰æ–¹æ³•ï¼Œå’Œ **LoRA**ã€**LoHA** ç±»ä¼¼ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯åœ¨é¢„è®­ç»ƒå¤§æ¨¡å‹å‚æ•°çš„åŸºç¡€ä¸Šï¼Œ**å†»ç»“åŸå§‹æƒé‡**ï¼Œåªå­¦ä¹ ä¸€ä¸ªä½ç§©çš„æ›´æ–°çŸ©é˜µ $\Delta W$ã€‚

ä¸åŒä¹‹å¤„åœ¨äºï¼š

* **LoRA**ï¼š $\Delta W = BA$ ï¼Œä½ç§©è¿‘ä¼¼ã€‚
* **LoHA**ï¼š $\Delta W = (BA) \odot (DC)$ ï¼Œç”¨ Hadamard ç§¯å¢å¼ºè¡¨è¾¾èƒ½åŠ›ã€‚
* **LoKr**ï¼š $\Delta W$ ä½¿ç”¨ **Kronecker ç§¯ (âŠ—)** è¡¨ç¤ºï¼Œå³ï¼š

  $$
  \Delta W = A \otimes B
  $$

  å…¶ä¸­ $A, B$ æ˜¯è¾ƒå°çš„çŸ©é˜µã€‚

è¿™æ ·ï¼ŒLoKr èƒ½ç”¨æ›´å°‘çš„å‚æ•°è¡¨ç¤ºä¸€ä¸ªå¤§çŸ©é˜µæ›´æ–°ï¼Œé€‚åˆåœ¨æ›´å¤§è§„æ¨¡æ¨¡å‹ä¸ŠèŠ‚çœæ˜¾å­˜å’Œè®¡ç®—ã€‚



## 2. æ•°å­¦å…¬å¼

è®¾åŸå§‹æƒé‡çŸ©é˜µ $W \in \mathbb{R}^{d \times k}$ï¼Œå†»ç»“ä¸åŠ¨ã€‚LoKr çš„ä½ç§©æ›´æ–°ä¸ºï¼š

1. **æœ‰æ•ˆæƒé‡**ï¼š

$$
W^{\text{eff}} = W + \Delta W
$$

2. **Kronecker åˆ†è§£å½¢å¼**ï¼š

$$
\Delta W = A \otimes B
$$

å…¶ä¸­ï¼š

* $A \in \mathbb{R}^{m \times n}$ï¼Œ$B \in \mathbb{R}^{p \times q}$
* Kronecker ç§¯ç»“æœ $\Delta W \in \mathbb{R}^{(m p) \times (n q)}$
* é€šè¿‡é€‰æ‹©åˆé€‚çš„ $m,n,p,q$ï¼Œå¯ä»¥è¿‘ä¼¼åŸå§‹æƒé‡ç»´åº¦ $(d \times k)$ã€‚

è®­ç»ƒæ—¶ï¼Œåªæ›´æ–° $A, B$ï¼Œå…¶å‚æ•°é‡è¿œå°äºå®Œæ•´çš„ $d \times k$ã€‚



## 3. æœ€ç®€ä»£ç ä¾‹å­

ç”¨ **PyTorch** å®ç°ä¸€ä¸ªæç®€ LoKr çº¿æ€§å±‚ï¼š

```python
import torch
import torch.nn as nn

class LoKrLinear(nn.Module):
    def __init__(self, in_features, out_features, m=2, n=2):
        super().__init__()
        # å†»ç»“çš„åŸå§‹æƒé‡
        self.weight = nn.Parameter(torch.randn(out_features, in_features), requires_grad=False)

        # LoKr å‚æ•° (ä¸¤ä¸ªå°çŸ©é˜µ)
        self.A = nn.Parameter(torch.randn(m, n) * 0.01)
        # Kronecker å¦ä¸€éƒ¨åˆ†çŸ©é˜µå½¢çŠ¶æ¨å¯¼
        p, q = out_features // m, in_features // n
        self.B = nn.Parameter(torch.randn(p, q) * 0.01)

    def forward(self, x):
        # Kronecker ç§¯ç”Ÿæˆ Î”W
        delta_W = torch.kron(self.A, self.B)  # Kronecker product
        W_eff = self.weight + delta_W
        return x @ W_eff.T

# ===== æµ‹è¯• =====
x = torch.randn(2, 8)   # è¾“å…¥ [batch, in_features]
layer = LoKrLinear(8, 4, m=2, n=2)  # out=4, in=8
out = layer(x)
print("è¾“å‡ºå½¢çŠ¶:", out.shape)
```

è¾“å‡ºï¼š

```
è¾“å‡ºå½¢çŠ¶: torch.Size([2, 4])
```

è¯´æ˜ LoKr å±‚æ­£å¸¸è¿è¡Œã€‚



## æ€»ç»“

* **LoKr** ç”¨ Kronecker ç§¯ $(A \otimes B)$ æ¥æ„é€ ä½ç§©æ›´æ–°ã€‚
* è¿™æ ·å‚æ•°é‡ä» $O(dk)$ é™åˆ° $O(mn + pq)$ï¼Œä½†ä»èƒ½è¿‘ä¼¼è¡¨è¾¾å¤§çŸ©é˜µæ›´æ–°ã€‚
* é€‚åˆåœ¨å¤§æ¨¡å‹ï¼ˆå¦‚ LLMï¼‰ä¸­åšå‚æ•°é«˜æ•ˆå¾®è°ƒã€‚


## ğŸ”¹ LoRA / LoHA / LoKr å¾®è°ƒæ–¹æ³•å¯¹æ¯”

| æ–¹æ³•       | æ›´æ–°å…¬å¼                           | é¢å¤–å‚æ•°è§„æ¨¡                            | è¡¨è¾¾èƒ½åŠ›                    | ç‰¹ç‚¹                         |
| -------- | ------------------------------ | --------------------------------- | ----------------------- | -------------------------- |
| **LoRA** | $\Delta W = B A$               | $O(d r + r k)$                    | ä¸­ç­‰ï¼ˆä½ç§©çº¿æ€§è¿‘ä¼¼ï¼‰              | æœ€ç»å…¸çš„ PEFT æ–¹æ³•ï¼Œå‚æ•°é‡å°ï¼Œæ•ˆæœå¥½ï¼Œç®€å•é«˜æ•ˆ |
| **LoHA** | $\Delta W = (B A) \odot (D C)$ | $O(2 (d r + r k))$                | è¾ƒå¼ºï¼ˆHadamard é€å…ƒç´ ä¹˜å¢å¼ºè¡¨ç¤ºï¼‰   | åœ¨ä¿æŒä½ç§©çš„åŒæ—¶å¢å¼ºéçº¿æ€§å»ºæ¨¡èƒ½åŠ›ï¼Œé€‚åˆå¤æ‚ä»»åŠ¡   |
| **LoKr** | $\Delta W = A \otimes B$       | $O(m n + p q)$ ï¼ˆè¿œå°äº $d \times k$ï¼‰ | è¾ƒå¼ºï¼ˆKronecker ç§¯èƒ½è¡¨è¾¾å¤§çŸ©é˜µç»“æ„ï¼‰ | å‚æ•°é‡æå°ä½†èƒ½è¡¨ç¤ºå¤§çŸ©é˜µï¼Œç‰¹åˆ«é€‚åˆå¤§æ¨¡å‹çš„æ˜¾å­˜ä¼˜åŒ–  |


## æ€»ç»“

* **LoRA**ï¼šæœ€åŸºç¡€çš„ä½ç§©è¿‘ä¼¼ï¼Œç®€å•å®ç”¨ï¼Œå¹¿æ³›åº”ç”¨äº LLM å¾®è°ƒã€‚
* **LoHA**ï¼šåœ¨ LoRA åŸºç¡€ä¸Šå¢åŠ  Hadamard ä¹˜ç§¯ï¼Œè¡¨ç¤ºèƒ½åŠ›æ›´å¼ºï¼Œé€‚åˆæ›´å¤æ‚çš„ä»»åŠ¡ã€‚
* **LoKr**ï¼šåˆ©ç”¨ Kronecker ç§¯ï¼Œç”¨å¾ˆå°‘çš„å‚æ•°è¿‘ä¼¼å¤§çŸ©é˜µæ›´æ–°ï¼Œé€‚åˆåœ¨è¶…å¤§æ¨¡å‹ä¸­è¿›ä¸€æ­¥èŠ‚çœæ˜¾å­˜ã€‚



