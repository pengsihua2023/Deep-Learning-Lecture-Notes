## å›¾ç¥ç»ç½‘ç»œ Graph Neural Network (GNNï¼‰
**Graph Neural Network (GNN)** æ˜¯ä¸€ç§ä¸“é—¨ç”¨äºå¤„ç†å›¾ç»“æ„æ•°æ®ï¼ˆGraph-structured Dataï¼‰çš„ç¥ç»ç½‘ç»œæ¨¡å‹ã€‚
åœ¨å›¾ä¸­ï¼ŒèŠ‚ç‚¹ï¼ˆnodes/verticesï¼‰è¡¨ç¤ºå®ä½“ï¼Œè¾¹ï¼ˆedgesï¼‰è¡¨ç¤ºå®ä½“ä¹‹é—´çš„å…³ç³»ã€‚ä¸ä¼ ç»Ÿç¥ç»ç½‘ç»œä¸åŒï¼ŒGNN èƒ½å¤Ÿæ•æ‰ **èŠ‚ç‚¹ä¹‹é—´çš„ä¾èµ–å…³ç³»** å’Œ **å›¾çš„æ‹“æ‰‘ç»“æ„**ï¼Œä»è€Œå­¦ä¹ åˆ°èŠ‚ç‚¹ã€è¾¹æˆ–æ•´ä¸ªå›¾çš„æœ‰æ•ˆè¡¨ç¤ºï¼ˆembeddingï¼‰ã€‚
<div align="center">
<img width="600" height="200" alt="image" src="https://github.com/user-attachments/assets/6c67a274-3a8c-4282-80ab-076bf0d47b61" /> 
</div> 

<div align="center">
(æ­¤å›¾å¼•è‡ªInternetã€‚)
</div> 

### ğŸ“– æ ¸å¿ƒæ€æƒ³

1. **æ¶ˆæ¯ä¼ é€’ï¼ˆMessage Passingï¼‰**ï¼š
   æ¯ä¸ªèŠ‚ç‚¹ä»å…¶é‚»å±…èŠ‚ç‚¹æ”¶é›†ä¿¡æ¯ï¼Œå¹¶ç»“åˆè‡ªèº«ç‰¹å¾è¿›è¡Œæ›´æ–°ã€‚

2. **èšåˆï¼ˆAggregationï¼‰**ï¼š
   ä½¿ç”¨æŸç§å‡½æ•°ï¼ˆå¦‚æ±‚å’Œã€å¹³å‡ã€æœ€å¤§æ± åŒ–ï¼‰å°†é‚»å±…ä¿¡æ¯èšåˆèµ·æ¥ï¼Œä¿è¯ç»“æœå¯¹èŠ‚ç‚¹é‚»å±…çš„é¡ºåºä¸æ•æ„Ÿã€‚

3. **æ›´æ–°ï¼ˆUpdateï¼‰**ï¼š
   å°†èšåˆåçš„é‚»å±…ä¿¡æ¯ä¸èŠ‚ç‚¹è‡ªèº«ç‰¹å¾ç»“åˆï¼Œé€šè¿‡ç¥ç»ç½‘ç»œï¼ˆå¦‚ MLPï¼‰æ›´æ–°èŠ‚ç‚¹è¡¨ç¤ºã€‚

4. **è¿­ä»£ä¼ æ’­ï¼ˆPropagationï¼‰**ï¼š
   é‡å¤ä¸Šè¿°è¿‡ç¨‹å¤šå±‚æ¬¡ä¼ æ’­ï¼Œä½¿å¾—èŠ‚ç‚¹èƒ½å¤Ÿæ•æ‰åˆ°æ›´è¿œè·ç¦»çš„é‚»å±…ä¿¡æ¯ã€‚

### ğŸ“– å¸¸è§ä»»åŠ¡

* **èŠ‚ç‚¹åˆ†ç±» (Node Classification)**ï¼šé¢„æµ‹èŠ‚ç‚¹çš„ç±»åˆ«ï¼Œä¾‹å¦‚ç¤¾äº¤ç½‘ç»œä¸­ç”¨æˆ·çš„å…´è¶£æ ‡ç­¾ã€‚
* **é“¾è·¯é¢„æµ‹ (Link Prediction)**ï¼šé¢„æµ‹å›¾ä¸­ç¼ºå¤±æˆ–æœªæ¥å¯èƒ½å‡ºç°çš„è¾¹ï¼Œä¾‹å¦‚æ¨èç³»ç»Ÿä¸­çš„â€œæœ‹å‹æ¨èâ€ã€‚
* **å›¾åˆ†ç±» (Graph Classification)**ï¼šå¯¹æ•´ä¸ªå›¾è¿›è¡Œåˆ†ç±»ï¼Œä¾‹å¦‚åˆ†å­ç»“æ„å›¾çš„è¯ç‰©æ´»æ€§é¢„æµ‹ã€‚



### ğŸ“– å›¾ç¥ç»ç½‘ç»œçš„æ•°å­¦æè¿°

### 1. å›¾çš„åŸºæœ¬ç»“æ„

ä¸€ä¸ªå›¾å®šä¹‰ä¸ºä¸‰å…ƒç»„ï¼š

$G = (V, E, X)$

å…¶ä¸­ï¼š

* $V = \{1, 2, \dots, N\}$ ä¸ºèŠ‚ç‚¹é›†åˆï¼ŒèŠ‚ç‚¹æ•°ä¸º $N$ã€‚
* $E \subseteq V \times V$ ä¸ºè¾¹é›†åˆã€‚
* $X \in \mathbb{R}^{N \times d}$ ä¸ºèŠ‚ç‚¹ç‰¹å¾çŸ©é˜µï¼Œå…¶ä¸­ç¬¬ $i$ è¡Œ $x_i \in \mathbb{R}^d$ æ˜¯èŠ‚ç‚¹ $i$ çš„åˆå§‹ç‰¹å¾ã€‚

é‚»æ¥çŸ©é˜µè¡¨ç¤ºï¼š $A \in \mathbb{R}^{N \times N}, \quad A_{ij} \neq 0 \text{è¡¨ç¤º} (i,j) \in E$

### 2. èŠ‚ç‚¹è¡¨ç¤ºçš„è¿­ä»£æ›´æ–°

æ¶ˆæ¯ä¼ é€’ (Message Passing) çš„ä¸€èˆ¬å½¢å¼ï¼š

<img width="500" height="52" alt="image" src="https://github.com/user-attachments/assets/e3732160-4870-4514-a875-7afaf4907056" />

è¯´æ˜ï¼š

* $\mathcal{N}(i)$ï¼šèŠ‚ç‚¹ $i$ çš„é‚»å±…é›†åˆï¼ˆå¯å«è‡ªèº«ï¼‰ã€‚
* $\phi^{(k)}$ï¼šèšåˆå‡½æ•° (aggregation)ã€‚
* $\psi^{(k)}$ï¼šæ›´æ–°å‡½æ•° (update)ã€‚
* èŠ‚ç‚¹æœ€ç»ˆåµŒå…¥ï¼š

<img width="160" height="43" alt="image" src="https://github.com/user-attachments/assets/c9628b49-a5b5-42cf-b2d6-f155d10432e1" />

### 3. å›¾çº§è¡¨ç¤º

è‹¥ä»»åŠ¡éœ€è¦å¯¹æ•´ä¸ªå›¾è¿›è¡Œé¢„æµ‹ï¼ˆå¦‚å›¾åˆ†ç±»ï¼‰ï¼Œåˆ™åœ¨æœ€åä¸€å±‚èŠ‚ç‚¹è¡¨ç¤ºçš„åŸºç¡€ä¸Šå®šä¹‰å›¾è¡¨ç¤ºï¼š

<img width="220" height="48" alt="image" src="https://github.com/user-attachments/assets/f0325b8f-b158-4ee5-aef0-d67f6c046c4b" />


å…¶ä¸­ $\rho$ æ˜¯è¯»å‡ºå‡½æ•° (readout)ï¼Œå¸¸è§å–æ³•ä¸º sumã€meanã€max pooling æˆ–æ³¨æ„åŠ›åŠ æƒã€‚

### 4. ç‰¹ä¾‹ï¼šå¸¸è§ GNN å®ç°

### GCN (Graph Convolutional Network)

$$
H^{(k)} = \sigma\left(\tilde{D}^{-\tfrac{1}{2}} \tilde{A} \tilde{D}^{-\tfrac{1}{2}} H^{(k-1)} W^{(k)}\right)
$$

å…¶ä¸­ $\tilde{A} = A + I$ï¼Œ$\tilde{D}$ æ˜¯ $\tilde{A}$ çš„åº¦çŸ©é˜µã€‚

### GraphSAGE

<img width="500" height="52" alt="image" src="https://github.com/user-attachments/assets/e5fa2b76-2764-4686-8a1d-dc873abfb520" />

### GAT (Graph Attention Network)

$$
h_i^{(k)} = \sigma\left(\sum_{j \in \mathcal{N}(i)} 
\alpha_{ij}^{(k)} W^{(k)} h_j^{(k-1)}\right)
$$

å…¶ä¸­ $\alpha_{ij}^{(k)}$ æ˜¯æ³¨æ„åŠ›æƒé‡ï¼š

### 5. æ€»ç»“

GNN çš„ä¸€èˆ¬æ•°å­¦å®šä¹‰å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š

- **è¾“å…¥**ï¼šå›¾ $G=(V,E,X)$ã€‚
- **ä¼ æ’­è§„åˆ™**ï¼š

<img width="400" height="50" alt="image" src="https://github.com/user-attachments/assets/422ed3a2-ad2e-4800-8cdb-4a6c3e42f741" />


- **è¾“å‡º**ï¼šèŠ‚ç‚¹åµŒå…¥ $H^{(K)}$ æˆ–å›¾åµŒå…¥ $h_G$ã€‚

---

## ğŸ“– ä»£ç 
ç¼–å†™ä¸€ä¸ªåŸºäºPyTorchå’ŒPyTorch Geometricçš„æœ€ç®€å•Graph Neural Networkï¼ˆGNNï¼‰ç¤ºä¾‹ï¼Œä½¿ç”¨çœŸå®æ•°æ®é›†ï¼ˆCoraæ•°æ®é›†ï¼Œå¸¸ç”¨çš„å›¾åˆ†ç±»åŸºå‡†æ•°æ®é›†ï¼‰ï¼Œå®ç°èŠ‚ç‚¹åˆ†ç±»ä»»åŠ¡ã€‚æ¨¡å‹ä½¿ç”¨ç®€å•çš„Graph Convolutional Networkï¼ˆGCNï¼‰ã€‚ç»“æœå°†é€šè¿‡å¯è§†åŒ–èŠ‚ç‚¹åµŒå…¥ï¼ˆt-SNEé™ç»´ï¼‰å’Œè¯„ä¼°åˆ†ç±»å‡†ç¡®ç‡æ¥å±•ç¤ºã€‚

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.datasets import Planetoid
from torch_geometric.nn import GCNConv
from torch_geometric.loader import DataLoader
import numpy as np
from sklearn.manifold import TSNE
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score

# å®šä¹‰ç®€å•çš„GCNæ¨¡å‹
class SimpleGCN(nn.Module):
    def __init__(self, in_channels, hidden_channels, out_channels):
        super(SimpleGCN, self).__init__()
        self.conv1 = GCNConv(in_channels, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, out_channels)
    
    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, p=0.5, training=self.training)
        x = self.conv2(x, edge_index)
        return x

# å¯è§†åŒ–èŠ‚ç‚¹åµŒå…¥
def visualize_embeddings(embeddings, labels, num_classes, title="t-SNE Visualization of Node Embeddings"):
    tsne = TSNE(n_components=2, random_state=42)
    embeddings_2d = tsne.fit_transform(embeddings)
    
    plt.figure(figsize=(10, 8))
    for i in range(num_classes):
        mask = labels == i
        plt.scatter(embeddings_2d[mask, 0], embeddings_2d[mask, 1], label=f'Class {i}', alpha=0.5)
    plt.legend()
    plt.title(title)
    plt.savefig('cora_embeddings.png')
    plt.close()
    print("t-SNE visualization saved as 'cora_embeddings.png'")

# è®­ç»ƒå’Œè¯„ä¼°
def train_and_evaluate(model, data, epochs=200):
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01, weight_decay=5e-4)
    criterion = nn.CrossEntropyLoss()
    
    model.train()
    for epoch in range(epochs):
        optimizer.zero_grad()
        out = model(data)
        loss = criterion(out[data.train_mask], data.y[data.train_mask])
        loss.backward()
        optimizer.step()
        
        if (epoch + 1) % 50 == 0:
            model.eval()
            with torch.no_grad():
                pred = out.argmax(dim=1)
                acc = accuracy_score(data.y[data.val_mask].cpu(), pred[data.val_mask].cpu())
            print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}, Validation Accuracy: {acc:.4f}')
            model.train()
    
    # æµ‹è¯•é›†è¯„ä¼°
    model.eval()
    with torch.no_grad():
        out = model(data)
        pred = out.argmax(dim=1)
        test_acc = accuracy_score(data.y[data.test_mask].cpu(), pred[data.test_mask].cpu())
        print(f'\nTest Accuracy: {test_acc:.4f}')
        
        # è·å–åµŒå…¥ï¼ˆæœ€åä¸€å±‚è¾“å‡ºï¼‰
        embeddings = out.cpu().numpy()
        labels = data.y.cpu().numpy()
        visualize_embeddings(embeddings, labels, num_classes=data.num_classes)

def main():
    # åŠ è½½Coraæ•°æ®é›†
    dataset = Planetoid(root='./data', name='Cora')
    data = dataset[0]
    data = data.to(device)
    
    # åˆå§‹åŒ–æ¨¡å‹
    model = SimpleGCN(in_channels=dataset.num_features, hidden_channels=16, out_channels=dataset.num_classes).to(device)
    
    # è®­ç»ƒå’Œè¯„ä¼°
    train_and_evaluate(model, data)

if __name__ == "__main__":
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    main()
```

### ğŸ“– ä»£ç è¯´æ˜ï¼š
1. **æ•°æ®é›†**ï¼š
   - ä½¿ç”¨Coraæ•°æ®é›†ï¼ˆ2708ä¸ªèŠ‚ç‚¹ï¼Œ7ä¸ªç±»åˆ«ï¼Œ1433ç»´ç‰¹å¾ï¼Œè¡¨ç¤ºå­¦æœ¯è®ºæ–‡åŠå…¶å¼•ç”¨å…³ç³»ï¼‰ã€‚
   - æ¯ä¸ªèŠ‚ç‚¹æ˜¯è®ºæ–‡ï¼Œç‰¹å¾æ˜¯è¯è¢‹è¡¨ç¤ºï¼Œè¾¹æ˜¯å¼•ç”¨å…³ç³»ï¼Œä»»åŠ¡æ˜¯é¢„æµ‹è®ºæ–‡ç±»åˆ«ã€‚
   - æ•°æ®é€šè¿‡`torch_geometric`çš„`Planetoid`åŠ è½½ï¼ŒåŒ…å«è®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•æ©ç ã€‚

2. **æ¨¡å‹ç»“æ„**ï¼š
   - ç®€å•GCNï¼šä¸¤å±‚GCNConvï¼ˆå›¾å·ç§¯å±‚ï¼‰ï¼Œç¬¬ä¸€å±‚å°†1433ç»´ç‰¹å¾æ˜ å°„åˆ°16ç»´ï¼Œç¬¬äºŒå±‚æ˜ å°„åˆ°7ç»´ï¼ˆç±»åˆ«æ•°ï¼‰ã€‚
   - ä½¿ç”¨ReLUæ¿€æ´»å’ŒDropoutï¼ˆp=0.5ï¼‰é˜²æ­¢è¿‡æ‹Ÿåˆã€‚

3. **è®­ç»ƒ**ï¼š
   - ä½¿ç”¨Adamä¼˜åŒ–å™¨ï¼Œå­¦ä¹ ç‡0.01ï¼Œæƒé‡è¡°å‡5e-4ï¼Œè®­ç»ƒ200ä¸ªepochã€‚
   - æŸå¤±å‡½æ•°ä¸ºäº¤å‰ç†µï¼Œä»…å¯¹è®­ç»ƒæ©ç çš„èŠ‚ç‚¹è®¡ç®—æŸå¤±ã€‚
   - æ¯50ä¸ªepochæ‰“å°è®­ç»ƒæŸå¤±å’ŒéªŒè¯é›†å‡†ç¡®ç‡ã€‚

4. **è¯„ä¼°ä¸å¯è§†åŒ–**ï¼š
   - **è¯„ä¼°**ï¼šåœ¨æµ‹è¯•é›†ä¸Šè®¡ç®—èŠ‚ç‚¹åˆ†ç±»å‡†ç¡®ç‡ã€‚
   - **å¯è§†åŒ–**ï¼šå¯¹æ¨¡å‹è¾“å‡ºçš„èŠ‚ç‚¹åµŒå…¥ï¼ˆæœ€åä¸€å±‚è¾“å‡ºï¼‰ä½¿ç”¨t-SNEé™ç»´åˆ°2Dï¼Œç»˜åˆ¶æ•£ç‚¹å›¾ï¼ŒæŒ‰ç±»åˆ«ç€è‰²ï¼Œä¿å­˜ä¸º`cora_embeddings.png`ã€‚
   - ç†æƒ³æƒ…å†µä¸‹ï¼ŒåŒä¸€ç±»åˆ«çš„èŠ‚ç‚¹åœ¨åµŒå…¥ç©ºé—´ä¸­åº”èšç±»ã€‚

5. **ä¾èµ–**ï¼š
   - éœ€å®‰è£…`torch`ã€`torch_geometric`ã€`sklearn`ã€`matplotlib`ï¼ˆ`pip install torch torch-geometric scikit-learn matplotlib`ï¼‰ã€‚
   - Coraæ•°æ®é›†ä¼šè‡ªåŠ¨ä¸‹è½½åˆ°`./data`ç›®å½•ã€‚

### ğŸ“– è¿è¡Œç»“æœï¼š
- è¾“å‡ºæ¯50ä¸ªepochçš„è®­ç»ƒæŸå¤±å’ŒéªŒè¯å‡†ç¡®ç‡ã€‚
- è¾“å‡ºæµ‹è¯•é›†çš„æœ€ç»ˆåˆ†ç±»å‡†ç¡®ç‡ã€‚
- ç”Ÿæˆ`cora_embeddings.png`ï¼Œå±•ç¤ºèŠ‚ç‚¹åµŒå…¥çš„2Dåˆ†å¸ƒï¼Œé¢œè‰²è¡¨ç¤ºä¸åŒç±»åˆ«ã€‚
- æ•£ç‚¹å›¾åæ˜ GNNæ˜¯å¦å­¦ä¹ åˆ°æœ‰æ„ä¹‰çš„åµŒå…¥ï¼ˆåŒç±»èŠ‚ç‚¹åº”é è¿‘ï¼Œå¼‚ç±»èŠ‚ç‚¹åº”åˆ†å¼€ï¼‰ã€‚

### ğŸ“– æ³¨æ„ï¼š
- æ•£ç‚¹å›¾ä¿å­˜åœ¨è¿è¡Œç›®å½•ä¸‹ï¼Œå¯ç”¨å›¾åƒæŸ¥çœ‹å™¨æ£€æŸ¥ã€‚
- æ¨¡å‹ç®€å•ï¼ˆä¸¤å±‚GCNï¼‰ï¼Œé€‚åˆå±•ç¤ºGNNæ¦‚å¿µï¼›å®é™…åº”ç”¨å¯å¢åŠ å±‚æ•°æˆ–ä½¿ç”¨æ›´å¤æ‚çš„GNNå˜ä½“ï¼ˆå¦‚GATï¼‰ã€‚
